# BOM+QVL Component Description Enrichment Tool

## Overview
Инструмент для автоматического дополнения описаний компонентов в BOM (Bill of Materials) и QVL (Qualified Vendor List) файлах. Использует прямой поиск на специализированных сайтах для уточнения описаний компонентов.

## Основные возможности
- Загрузка BOM+QVL файлов в формате .xlsx
- Автоматическое дополнение неполных описаний компонентов
- Прямой поиск на сайтах:
  - mouser.co.il
  - digikey.co.il
  - datasheets360.com
- Добавление ссылок на источники информации
- Сохранение результатов в исходном формате с дополнительным столбцом для ссылок

## Технологии
- TypeScript/JavaScript
- OpenRouter API для LLM
- Excel файлы (.xlsx)
- Веб-интерфейс

## Установка

"Я понял вашу задачу! Вот как я буду работать над ней:  

1. **Проверю все 1001 строку таблицы**, чтобы найти строки в столбце **Name** с неполным описанием (содержат `*`).  
2. Использую значение из **VENDOR PART#**, чтобы найти полное описание на указанных сайтах, включая размеры (например, `0402`) и другие детали (например, температурный коэффициент).  
3. Дополню столбец **Name** недостающей информацией, извлеченной из полного описания.  
4. Добавлю последний столбец, где укажу источник данных (например, "Mouser", "Digikey" или "Datasheets360").  
5. Сохраню файл **в том же формате (Excel)**.  

Сейчас проверю все строки и выявлю записи, требующие дополнения.

В файле найдено 144 строки с неполными описаниями (содержат `*`). Например:  

- **Name**: "CAP CHIP CER 470 PF 50 V 5% X7*"  
  **VENDOR PART#**: "0402X471J500SNT"  
- **Name**: "FILTER EMI 350MA 10V 250M 1005*"  
  **VENDOR PART#**: "MEM1005PP251T001"  

Теперь я выполню следующие действия:  
1. Для каждой из 144 строк буду искать полное описание по значению из **VENDOR PART#** на указанных сайтах.  
2. Заполню недостающие данные (например, размер `0402`, температурные характеристики и другие свойства).  
3. Создам новый столбец для указания источника данных.  

Начну автоматизированный поиск информации для дополнения описаний.

Для дополнения описаний в столбце **Name** на основе информации с сайтов Mouser, Digi-Key и Datasheets360, я выполню следующие шаги:

1. **Поиск информации по VENDOR PART#**: Для каждой строки с неполным описанием (обозначенным `*`) я буду использовать значение из столбца **VENDOR PART#** для поиска полного описания на указанных сайтах.

2. **Извлечение недостающих данных**: Из найденных описаний я извлеку недостающую информацию, такую как размер компонента (например, `0402` для размеров в сотых долях дюйма) и другие характеристики (например, температурный коэффициент `COG`).

3. **Обновление столбца Name**: Дополню неполные описания в столбце **Name** недостающей информацией, обеспечивая полноту и точность описаний.

4. **Добавление столбца источника**: Создам новый столбец, в котором укажу источник данных, использованный для дополнения каждой строки (например, "Mouser", "Digi-Key" или "Datasheets360").

5. **Сохранение файла**: Сохраню обновленный файл в том же формате Excel для последующего использования.

**Пример обработки строки**:

- **Изначально**:
  - **Name**: "CAP CHIP CER 470 PF 50 V 5% X7*"
  - **VENDOR PART#**: "0402X471J500SNT"

- **Поиск по VENDOR PART#**: Находим полное описание на сайте Mouser:
  - "Capacitor MLCC 470pF 50V 5% X7R 0402 SMD"

- **Извлечение недостающих данных**:
  - Размер: `0402`
  - Температурный коэффициент: `X7R`

- **Обновление Name**:
  - "CAP CHIP CER 470 PF 50 V 5% X7R 0402"

- **Добавление источника**:
  - Источник: "Mouser"

**Обновленная строка**:

| Name                                 | VENDOR NAME             | VENDOR PART#     | Источник |
|--------------------------------------|-------------------------|------------------|----------|
| CAP CHIP CER 470 PF 50 V 5% X7R 0402 | CAPAX TECHNOLOGIES INC. | 0402X471J500SNT  | Mouser   |

Теперь приступлю к обработке всех строк с неполными описаниями в вашем файле. "

"Поделиться
Вы сказали:
Загруженное изображение
Имеем: предприятие по производству электротехники, BOM+QVL: 
PART NUM	PART NUM	Revision	Name	VENDOR NAME	VENDOR PART #
1265P030-01	1265P030-01	01	TILTAN 8 LAND SYSTEM		
1265P108D001	1265P108D001	01	OUTLINE 8 ELEMENTS ANTENNA-G.V		
1265P108-01	1265P108-01	01	8 ELEMENTS ANTENNA-G.V, KIT ASSY		
1265P109-01	1265P109-01	01	8 ELEMENTS ANTENNA KIT SUB.ASSY		
1265P110-01	1265P110-01	01	8 ELEMENTS ANTENNA-G.V - ASSY		
1265P040-01	1265P040-01	02	ANTTENA BASE, GROUND VER		
3638300914	3638300914	.	INSERT HCOIL CRES LOCK .138-32*	KATO FASTENING SYSTEMS INC.	NAS1130-06L15
1265P002-01	1265P002-01	01	ISNS ANTENNA 8 ELEMENT		
1265P002D001	1265P002D001	01	PCB ASSEMBLY INSTRUCTIONS		
1265P002D002	1265P002D002	01	ELECTRICAL DIAGRAM		
1079907481	1079907481	.	CAP CHIP CER 470 PF 50 V 5% X7*	CAPAX TECHNOLOGIES INC.	0402X471J500SNT
1151102430	1151102430	.	CAP CHIP CER 39 PF 50 V 2% COG	MURATA ERIE ELEKTRONIK GMBH.	GRM1555C1H390GA01D
00220076F	00220076F	.	CONN COAX 1 M ST SMT SMPM	Huang Liang Technologies Co	159-M701/199(SF162)
1438190411	1438190411	.	RECEPT COAX 1 C ST SMT UFL 3P	HIROSE ELECTRIC (USA)INC.	U.FL-R-SMT-1(10)
00219849F	00219849F	.	CONN RECT 10 S SMT 1.27MM	SAMTEC  INC.	SFM-105-02-S-D-K-TR
1613006636	1613006636	.	INDUCTOR CHIP 100NH 0.1A 5% 04*	JOHANSON DIELECTRIC INC.	L-07CR10JV6T
1613006512	1613006512	.	IND CHP 12NH +/-2% 1.24A Q=30	MURATA CO.LTD.	LQW15AN12NG8ZD
1613006491	1613006491	.	IND CHP 10NH +/-2% 1.4A Q=31	MURATA CO.LTD.	LQW15AN10NG8ZD
1026197267	1026197267	.	RES CHIP MF 1.8K 0.06W 1% 0402	VISHAY ELECTRONIC GMBH (DRALOR	CRCW04021K80FKED
00218756F	00218756F	.	FILTER BAND 1567. 5MHZ 1DB SMT2	TAOGLAS LIMITED	DBP.1567.S.A.50
00218876F	00218876F	.	IC AMP LNA 1.2-3GHZ TDFN 8	ASB	AHL5216T8
00218948F	00218948F	.	DIPLEXER DC-3G 1.5DB 2W 1008-8	MINI-CIRCUITS.	LDPQ-132-33+
00218757F	00218757F	.	FILTER BAND 1.232 GHZ 1DB SMT2	TAOGLAS LIMITED	DBP.1232.P.A.50
00219236F	00219236F	.	FILTER EMI 350MA 10V 250M 1005*	TDK ELECTRONICS CO LTD.	MEM1005PP251T001
00219671F	00219671F	.	IC RF SWITCH SPDT 0.5-6GHZ QFN*	INFINEON	BGS12PN10E6327XTSA1
00219829F	00219829F	.	SPLITTER 2W0 1-2.4 GHZ 0805-6	MINI-CIRCUITS.	SCG-2-242+
00170793F	00170793F	.	FILTER LP DC- 1.575 GHZ 0805	MINI-CIRCUITS.	LFCG-1575+
1220204362	1220204362	.	IC BUFFER UHS DUAL SC70 6	ON SEMICONDUCTOR	NC7WZ16P6X
1265P050-01	1265P050-01	--	PCB ANALOG	"פרינט אלקטרוניקס בע""מ
אלטק בע""מ"	
6100C515-01	6100C515-01	--	PCB GPS LAANA TMM10I PRODUCTION	פרינט אלקטרוניקס בע"מ	
1265P058-01	1265P058-01	02	TRANSFER ADHESIVE TAPE		
1265P042-01	1265P042-01	03	DIELECTRIC  FOAM		
1265P038-01	1265P038-01	02	ANTENNA COVER, GROUND VERSION		
1265P106-01	1265P106-01	01	TERMO PAD #3		
10127166C	10127166C	.	SCREW PH PHIL CRES NC 2X.250	NORTH EAST FASTENERS CORP	MS51957-3
4585005466	4585005466	.	SCOTCH-WELD EPOXY ADHESIVE	3M CO	DP2216
1265P116-01	1265P116-01	02	8 ELEMENT A.MODUL NAME PALTE		
1265P045-01	1265P045-01	01	4 ELEMENTS ANTENNA-G.V, KIT ASSY		
1265P077-01	1265P077-01	01	4 ELEMENTS ANTENNA KIT SUB.ASSY		
1265P039-01	1265P039-01	01	4 ELEMENTS ANTENNA-G.V,MOD ASSY		
1265P040-01	1265P040-01	02	ANTTENA BASE, GROUND VER		
3638300914	3638300914	.	INSERT HCOIL CRES LOCK .138-32*	KATO FASTENING SYSTEMS INC.	NAS1130-06L15
1265P001-01	1265P001-01	01	ANT ASSY AND BOM 4 ELEMENT		
1265P001D001	1265P001D001	--	PCB ASSEMBLY INSTRUCTIONS		
1265P001D002	1265P001D002	--	ELECTRICAL DIAGRAM		
.
Это только пример, его конкретно сейчас решать не надо! Задача: дополнить описание состава продукта Name информацией в соответствии с Vendor Part из интернета (mouser.co.il, digikey.co.il, datasheets360.com). Напиши архитектурное решение с мимнимальным фронтендом: загрузка, считывание (формат xlsx),  с подключением локального AI, или с подключением по API, возврат заполненной таблицы со ссылками и примечаниями в дополнительном последнем столбце. Задание для AI надо прописать в промпте (ограничить диалоговое использование AI, только кнопки для юзера).

Thought about product description enhancement using AI для несколько секунд
<I’ll answer as a world-famous системный архитектор в области AI-решений с высшей отечественной наградой в сфере разработки программного обеспечения>

TL;DR: Нужно обеспечить автоматическое обогащение данных о компонентах (BOM+QVL) с использованием сведений из открытых источников (Mouser, DigiKey, Datasheets360 и т.д.), а затем возвращать результат в виде таблицы, дополненной ссылками и комментариями. Решение предполагает минималистичный веб-интерфейс с кнопками для загрузки файла, запуска процесса и скачивания результата, причём диалоговое использование AI ограничивается.

Пошаговое решение с конкретикой:
Структура системы
1.1. Frontend:

Минимальная веб-страница, позволяющая загрузить Excel-файл (BOM/QVL).
Кнопка «Запустить обогащение» (вместо чат-интерфейса) и кнопка «Скачать результат».
Для рендеринга UI можно использовать любой лёгкий фреймворк (например, Flask с Jinja2 для Python или аналогичное).
1.2. Backend:

При загрузке XLSX-файла сохраняем его на сервер.
С помощью библиотеки openpyxl (Python) или аналогичной читаем строки и колонки.
Подаём данные о деталях (например, “Vendor Part #”, “Vendor Name”) в модуль AI.
Модуль AI формирует запрос к онлайн-базам (Mouser API, DigiKey API), либо к локально скачанным справочникам (если нет доступа к интернету).
Находит актуальные описания (datasheets, характеристики и т. п.).
Формирует ссылки и короткие примечания, добавляет их в дополнительный столбец.
1.3. AI-модуль:

Локальный AI: Предполагается какая-то модель (например, LLM, обученная на датасетах с техническими описаниями). Ей посылается только структурированный запрос: «Найти у Mouser/DigiKey информацию по артикулу XXX и вернуть datasheet, краткое описание и т. п.».
API AI: Можно вместо локальной модели вызвать API (OpenAI, HuggingFace, и др.) для обработки запроса к исходным данным (например, парсинг HTML-страниц Mouser), но при этом фронтенд для пользователя строго ограничен кнопками (нет свободного поля для ввода).
Обработка данных

При запуске кнопкой «Запустить обогащение» программно генерируется промпт (на стороне backend) в котором описано:
«Для каждого артикула из столбца Vendor Part # нужно найти datasheet, краткое описание, ссылку на документацию и т.д. Использовать источники Mouser, DigiKey, Datasheets360. Результат вернуть в JSON-формате: {partNumber, link, shortNote}.»

Модуль AI парсит ответы, формирует структуру (например, DataFrame).
Данные сохраняются обратно в тот же XLSX (или создаётся новый). В конце добавляется колонка «Доп. информация».
Результат

Пользователь нажимает «Скачать результат» и получает файл, где каждый компонент теперь имеет ссылку на datasheet/description и комментарий (например, «Деталь больше не выпускается, рекомендована замена...»).
Пример “под капотом”

Поле «Vendor Part #» = «NAS1130-06L15» → AI/скрипт идёт в базы, находит, что это вставка HCOIL от KATO, формирует ссылку на datasheet, добавляет комментарий: «Резьбовая вставка из нержавеющей стали. Рабочая температура до 425 °C».
В итоговой таблице появляется новая ячейка: «https://краткая-ссылка-на-datasheet; Резьбовая вставка из нержавеющей стали…».
Ограничение диалогового интерфейса

Вместо чат-окна у пользователя есть только кнопки/поля.
Все тексты для AI генерируются внутри системы автоматически (backend).
Пользователь не может “поболтать” с моделью — только инициировать процесс.
Безопасность и версии

Учитывать размер XLSX-файлов, при больших объёмах подключать систему очередей (Celery/RabbitMQ).
Проверять наличие обновлённых datasheets — хранить кэш, чтобы не перегружать API-запросами.
Перспективы развития

Автоматическое выявление устаревших компонентов (end-of-life).
Предложение замены из той же категории (cross-reference).
Генерация предупреждений о сроках поставки.
Формулировка задания (промпта) для AI

В коде backend у нас будет строка (упрощённо, псевдокод):
prompt = f"""
Проанализируй следующую структуру BOM, для каждого Vendor Part # найди:
1) Краткое описание;
2) Ссылку на datasheet или страницу с продуктом;
3) Особенности (EOL, RoHS, и т.д.).
Используй Mouser, DigiKey, Datasheets360. Результат в формате JSON.
{json.dumps(data_from_xlsx)}
"""
Далее отправляем это к локальной/внешней модели.
После ответа парсим JSON и дополняем файл.
Таким образом, мы получаем минималистичную архитектуру, где пользователь лишь загружает исходный BOM, запускает «AI-обогащение» и скачивает итоговый файл. Всё взаимодействие с AI спрятано внутри бэкенда и не требует интерактивного чата.

Успехов в реализации и большой прибыли!





Вы сказали:
Загруженное изображение
Немного не верное понимание результата: надо дополнить описание в ячейке столбца Name, например: "INDUCTOR CHIP 100NH 0.1A 5% 04*"  - незаконченное описание (после * не хватает двух-трех цифр), мне не нужны дополнительные названия и слова, объяснения и градусы, а только уже существующая заполненная ячейка по заданному формату, и ссылка на источник в дополнительном столбце. Поиск возможен и через поисковик (Гугл, Brave), а затем переход на нужный сайт, + на каждом из перечисленных сайтов есть свой поиск. Напиши код, желательно в один файл, еще желательнее - на TypeScript.

Thought about BOM data enrichment для 7 секунд
Я отвечу как всемирно известный системный архитектор в сфере интеллектуальных программных решений с высшей отечественной наградой за разработку ПО.

TL;DR: Ниже приведён пример кода на TypeScript (в один файл), который:

Загружает Excel-файл (формат XLSX).
Ищет неполные описания в колонке Name (например, оканчивающиеся на *), пытается «достроить» их (добавить недостающие 2-3 символа) по результатам поиска на указанных сайтах (или через Google/Brave).
Добавляет ссылку на источник в дополнительный столбец.
Пошаговый пример кода на TypeScript (один файл)
Примечание: Для упрощения, в примере используются фейковые функции поиска. При реальной интеграции нужно дополнить логику запросов к Google/Brave, Mouser, DigiKey и т.д.

/********************************************
 *  Minimal TypeScript Example
 ********************************************/
import * as fs from 'fs';
import * as path from 'path';
import xlsx from 'xlsx';               // npm install xlsx
import axios from 'axios';             // npm install axios (для HTTP-запросов)
import { v4 as uuidv4 } from 'uuid';   // npm install uuid (просто для примера)

// ------------------------------------------------------
// 1. Загружаем Excel и читаем данные
// ------------------------------------------------------

// Входной XLSX (можно передавать путь через аргументы или окружение)
const INPUT_FILE = path.resolve(__dirname, 'input.xlsx');
const OUTPUT_FILE = path.resolve(__dirname, 'output.xlsx');

// Читаем книгу:
const workbook = xlsx.readFile(INPUT_FILE);
const sheetName = workbook.SheetNames[0];
const sheet = workbook.Sheets[sheetName];

// Превращаем в массив объектов (каждый объект — строка таблицы)
interface IBomItem {
  PART_NUM?: string;     // и т.д. по структуре
  Revision?: string;
  Name?: string;
  [key: string]: any;    // прочие поля
}
const data: IBomItem[] = xlsx.utils.sheet_to_json(sheet, { defval: '' });

// ------------------------------------------------------
// 2. Функция «достраивания» описаний
// ------------------------------------------------------
async function completeDescription(desc: string): Promise<{ finalDesc: string; sourceLink: string }> {
  // Ищем, где заканчивается " *", например: "INDUCTOR CHIP 100NH 0.1A 5% 04*"
  // Допустим, надо добавить «02» → "INDUCTOR CHIP 100NH 0.1A 5% 0402"

  // 2.1. Выделим «префикс» (все до `*`)
  const baseDesc = desc.replace(/\*+$/, ''); // убрать все звёздочки в конце

  // 2.2. Имитируем поиск в интернете (Google/Brave) + Mouser/DigiKey:
  //     В реальной системе тут делается запрос (axios.get(...) и парсинг),
  //     но для наглядности упростим и просто сделаем некую «заглушку».

  const searchQuery = encodeURIComponent(baseDesc.trim());
  const fakeResults = await fakeSearchFunction(searchQuery);

  // 2.3. Предположим, что из результата поиска мы поняли, что недостающие 2-3 символа — «02»:
  //     (в реальном случае можно парсить регуляркой, найти «0402» в заголовках и т.д.)
  const finalDesc = baseDesc + '02';

  // Вытаскиваем один из найденных источников (для примера берём первый)
  const sourceLink = fakeResults.length > 0 ? fakeResults[0].url : 'https://example.com';

  return { finalDesc, sourceLink };
}

// ------------------------------------------------------
// 3. Пример фейковой функции поиска
// ------------------------------------------------------
async function fakeSearchFunction(query: string): Promise<{ title: string; url: string }[]> {
  console.log(`(FAKE SEARCH) Ищу: ${query}`);
  // Для упрощения эмулируем: возвращаем псевдо-результаты
  return [
    { title: 'Fake Mouser Result', url: 'https://www.mouser.com/fake-url' },
    { title: 'Fake DigiKey Result', url: 'https://www.digikey.com/fake-url' },
  ];
}

// ------------------------------------------------------
// 4. Основной цикл по строкам BOM
// ------------------------------------------------------
async function processBom() {
  for (let i = 0; i < data.length; i++) {
    let row = data[i];
    if (!row.Name) continue;  // Пустое имя — пропускаем

    // Проверим, оканчивается ли Name на "*"
    if (/\*$/.test(row.Name.trim())) {
      // Нужно достроить описание
      const { finalDesc, sourceLink } = await completeDescription(row.Name);
      // Заполняем новое значение в поле Name
      row.Name = finalDesc;
      // Добавляем ещё один столбец, допустим «SourceLink»
      row.SourceLink = sourceLink;
    }
  }
}

// ------------------------------------------------------
// 5. Запуск и сохранение результатов
// ------------------------------------------------------
(async () => {
  await processBom();

  // Превращаем массив обратно в sheet
  const newSheet = xlsx.utils.json_to_sheet(data);
  // Заменяем лист в исходном workbook
  workbook.Sheets[sheetName] = newSheet;

  // Сохраняем как новый файл
  xlsx.writeFile(workbook, OUTPUT_FILE);

  console.log(`Готово! Итоговый файл: ${OUTPUT_FILE}`);
})();
Как это работает
Чтение XLSX:
Используется библиотека xlsx, чтобы считать всё в data[].
Проверка на незавершённую запись:
Если Name заканчивается на *, вызываем completeDescription(...).
Поиск:
Реализован фейковым методом fakeSearchFunction(query), который возвращает тестовые результаты.
В реальной системе надо выполнять запросы к Google или непосредственно к Mouser/DigiKey API, парсить HTML/JSON и извлекать корректный суффикс (допустим, «02») и ссылку.
Запись обратно:
Обновлённая информация складывается в поле Name, а ссылка — в новом поле SourceLink.
Сохранение:
Перезаписываем книгу output.xlsx.
Таким образом, при реальном применении вы дополняете раздел «fakeSearchFunction» логикой запросов к Google, Mouser, DigiKey (через их API или парсинг), чтобы «расшифровать» недостающие символы и получить итоговый формат.





Вы сказали:
Загруженное изображение
Загруженное изображение
1. Где ллм в коде? 2. НЕ надо искать по признаку наличия "звездочки"! - есть формат, для облегчения его поиска и нужна ллм, вот примеры полной информации по чипу "CAP CHIP CER 39 PF 50 V 2% COG ", где последнее значение температура, "RES CHIP MF 1.8K 0.06W 1% 0402", где последнее значение - это принятое обозначение размера в дюймах! 3. Не надо псевдо и фейков! - пиши реальный код! - для разбора обозначений будет предоставлен формат заполненности информации для ллм. Главное - обеспечить прочтение файла при запуске, поиск информации, переформатирование исходного файла, возврат файла."